# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activesupport` gem.
# Please instead update this file by running `bin/tapioca gem activesupport`.

::RUBY19 = T.let(T.unsafe(nil), TrueClass)

module ActiveSupport
  extend ::ActiveSupport::LazyLoadHooks

  def parse_json_times; end
  def parse_json_times=(val); end

  class << self
    def escape_html_entities_in_json(*_arg0, &_arg1); end
    def escape_html_entities_in_json=(arg); end
    def json_encoder(*_arg0, &_arg1); end
    def json_encoder=(arg); end
    def parse_json_times; end
    def parse_json_times=(val); end
    def time_precision(*_arg0, &_arg1); end
    def time_precision=(arg); end
    def use_standard_json_time_format(*_arg0, &_arg1); end
    def use_standard_json_time_format=(arg); end
  end
end

module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format = T.unsafe(nil)); end
end

module ActiveSupport::Inflector
  extend ::ActiveSupport::Inflector

  def camelize(term, uppercase_first_letter = T.unsafe(nil)); end
  def classify(table_name); end
  def constantize(camel_cased_word); end
  def dasherize(underscored_word); end
  def deconstantize(path); end
  def demodulize(path); end
  def foreign_key(class_name, separate_class_name_and_id_with_underscore = T.unsafe(nil)); end
  def humanize(lower_case_and_underscored_word, capitalize: T.unsafe(nil), keep_id_suffix: T.unsafe(nil)); end
  def inflections(locale = T.unsafe(nil)); end
  def ordinal(number); end
  def ordinalize(number); end
  def parameterize(string, separator: T.unsafe(nil), preserve_case: T.unsafe(nil), locale: T.unsafe(nil)); end
  def pluralize(word, locale = T.unsafe(nil)); end
  def safe_constantize(camel_cased_word); end
  def singularize(word, locale = T.unsafe(nil)); end
  def tableize(class_name); end
  def titleize(word, keep_id_suffix: T.unsafe(nil)); end
  def transliterate(string, replacement = T.unsafe(nil), locale: T.unsafe(nil)); end
  def underscore(camel_cased_word); end
  def upcase_first(string); end

  private

  def apply_inflections(word, rules, locale = T.unsafe(nil)); end
  def const_regexp(camel_cased_word); end
end

ActiveSupport::Inflector::ALLOWED_ENCODINGS_FOR_TRANSLITERATE = T.let(T.unsafe(nil), Array)

class ActiveSupport::Inflector::Inflections
  def initialize; end

  def acronym(word); end
  def acronyms; end
  def acronyms_camelize_regex; end
  def acronyms_underscore_regex; end
  def clear(scope = T.unsafe(nil)); end
  def human(rule, replacement); end
  def humans; end
  def irregular(singular, plural); end
  def plural(rule, replacement); end
  def plurals; end
  def singular(rule, replacement); end
  def singulars; end
  def uncountable(*words); end
  def uncountables; end

  private

  def define_acronym_regex_patterns; end
  def initialize_dup(orig); end

  class << self
    def instance(locale = T.unsafe(nil)); end
  end
end

class ActiveSupport::Inflector::Inflections::Uncountables < ::Array
  def initialize; end

  def <<(*word); end
  def add(words); end
  def delete(entry); end
  def uncountable?(str); end

  private

  def to_regex(string); end
end

module ActiveSupport::JSON
  class << self
    def decode(json); end
    def encode(value, options = T.unsafe(nil)); end
    def parse_error; end

    private

    def convert_dates_from(data); end
  end
end

ActiveSupport::JSON::DATETIME_REGEX = T.let(T.unsafe(nil), Regexp)
ActiveSupport::JSON::DATE_REGEX = T.let(T.unsafe(nil), Regexp)

module ActiveSupport::JSON::Encoding
  class << self
    def escape_html_entities_in_json; end
    def escape_html_entities_in_json=(_arg0); end
    def json_encoder; end
    def json_encoder=(_arg0); end
    def time_precision; end
    def time_precision=(_arg0); end
    def use_standard_json_time_format; end
    def use_standard_json_time_format=(_arg0); end
  end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def initialize(options = T.unsafe(nil)); end

  def encode(value); end
  def options; end

  private

  def jsonify(value); end
  def stringify(jsonified); end
end

ActiveSupport::JSON::Encoding::JSONGemEncoder::ESCAPED_CHARS = T.let(T.unsafe(nil), Hash)
ActiveSupport::JSON::Encoding::JSONGemEncoder::ESCAPE_REGEX_WITHOUT_HTML_ENTITIES = T.let(T.unsafe(nil), Regexp)
ActiveSupport::JSON::Encoding::JSONGemEncoder::ESCAPE_REGEX_WITH_HTML_ENTITIES = T.let(T.unsafe(nil), Regexp)

class ActiveSupport::JSON::Encoding::JSONGemEncoder::EscapedString < ::String
  def to_json(*_arg0); end
  def to_s; end
end

module ActiveSupport::LazyLoadHooks
  def on_load(name, options = T.unsafe(nil), &block); end
  def run_load_hooks(name, base = T.unsafe(nil)); end

  private

  def execute_hook(name, base, options, block); end
  def with_execution_control(name, block, once); end

  class << self
    def extended(base); end
  end
end

module ActiveSupport::Multibyte
  class << self
    def proxy_class; end
    def proxy_class=(klass); end
  end
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable

  def initialize(string); end

  def <=>(*_arg0, &_arg1); end
  def =~(*_arg0, &_arg1); end
  def acts_like_string?(*_arg0, &_arg1); end
  def as_json(options = T.unsafe(nil)); end
  def compose; end
  def decompose; end
  def grapheme_length; end
  def limit(limit); end
  def match?(*_arg0, &_arg1); end
  def method_missing(method, *args, &block); end
  def reverse; end
  def reverse!(*args); end
  def slice!(*args); end
  def split(*args); end
  def tidy_bytes(force = T.unsafe(nil)); end
  def tidy_bytes!(*args); end
  def titlecase; end
  def titleize; end
  def to_s; end
  def to_str; end
  def wrapped_string; end

  private

  def chars(string); end
  def respond_to_missing?(method, include_private); end
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode

  def compose(codepoints); end
  def decompose(type, codepoints); end
  def default_normalization_form; end
  def default_normalization_form=(_); end
  def tidy_bytes(string, force = T.unsafe(nil)); end

  private

  def recode_windows1252_chars(string); end
end

ActiveSupport::Multibyte::Unicode::UNICODE_VERSION = T.let(T.unsafe(nil), String)

class ActiveSupport::TimeZone
  include ::Comparable

  def initialize(name, utc_offset = T.unsafe(nil), tzinfo = T.unsafe(nil)); end

  def <=>(zone); end
  def =~(re); end
  def at(*args); end
  def encode_with(coder); end
  def formatted_offset(colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end
  def init_with(coder); end
  def iso8601(str); end
  def local(*args); end
  def local_to_utc(time, dst = T.unsafe(nil)); end
  def match?(re); end
  def name; end
  def now; end
  def parse(str, now = T.unsafe(nil)); end
  def period_for_local(time, dst = T.unsafe(nil)); end
  def period_for_utc(time); end
  def periods_for_local(time); end
  def rfc3339(str); end
  def strptime(str, format, now = T.unsafe(nil)); end
  def to_s; end
  def today; end
  def tomorrow; end
  def tzinfo; end
  def utc_offset; end
  def utc_to_local(time); end
  def yesterday; end

  private

  def parts_to_time(parts, now); end
  def time_now; end

  class << self
    def [](arg); end
    def all; end
    def clear; end
    def country_zones(country_code); end
    def create(*_arg0); end
    def find_tzinfo(name); end
    def new(name); end
    def seconds_to_utc_offset(seconds, colon = T.unsafe(nil)); end
    def us_zones; end

    private

    def load_country_zones(code); end
    def zones_map; end
  end
end

ActiveSupport::TimeZone::MAPPING = T.let(T.unsafe(nil), Hash)
ActiveSupport::TimeZone::UTC_OFFSET_WITHOUT_COLON = T.let(T.unsafe(nil), String)
ActiveSupport::TimeZone::UTC_OFFSET_WITH_COLON = T.let(T.unsafe(nil), String)

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options = T.unsafe(nil)); end
end

class Array
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::Mocha::Inspect::ArrayMethods

  def as_json(options = T.unsafe(nil)); end
end

class BigDecimal < ::Numeric
  include ::ActiveSupport::BigDecimalWithDefaultFormat

  def as_json(options = T.unsafe(nil)); end
end

BigDecimal::EXCEPTION_NaN = T.let(T.unsafe(nil), Integer)
BigDecimal::VERSION = T.let(T.unsafe(nil), String)

class Date
  include ::Comparable
  include ::Mocha::Inspect::DateMethods
  include ::DateAndTime::Zones

  def as_json(options = T.unsafe(nil)); end
  def inspect; end
  def readable_inspect; end
  def to_formatted_s(format = T.unsafe(nil)); end
  def to_s(format = T.unsafe(nil)); end
  def to_time(form = T.unsafe(nil)); end
  def xmlschema; end
end

Date::DATE_FORMATS = T.let(T.unsafe(nil), Hash)
Date::VERSION = T.let(T.unsafe(nil), String)
module DateAndTime; end

module DateAndTime::Zones
  def in_time_zone(zone = T.unsafe(nil)); end

  private

  def time_with_zone(time, zone); end
end

class DateTime < ::Date
  def <=>(other); end
  def advance(options); end
  def ago(seconds); end
  def as_json(options = T.unsafe(nil)); end
  def at_beginning_of_day; end
  def at_beginning_of_hour; end
  def at_beginning_of_minute; end
  def at_end_of_day; end
  def at_end_of_hour; end
  def at_end_of_minute; end
  def at_midday; end
  def at_middle_of_day; end
  def at_midnight; end
  def at_noon; end
  def beginning_of_day; end
  def beginning_of_hour; end
  def beginning_of_minute; end
  def change(options); end
  def end_of_day; end
  def end_of_hour; end
  def end_of_minute; end
  def formatted_offset(colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end
  def getgm; end
  def getlocal(utc_offset = T.unsafe(nil)); end
  def getutc; end
  def gmtime; end
  def in(seconds); end
  def inspect; end
  def localtime(utc_offset = T.unsafe(nil)); end
  def midday; end
  def middle_of_day; end
  def midnight; end
  def noon; end
  def nsec; end
  def readable_inspect; end
  def seconds_since_midnight; end
  def seconds_until_end_of_day; end
  def since(seconds); end
  def subsec; end
  def to_f; end
  def to_formatted_s(format = T.unsafe(nil)); end
  def to_i; end
  def to_s(format = T.unsafe(nil)); end
  def usec; end
  def utc; end
  def utc?; end
  def utc_offset; end

  private

  def offset_in_seconds; end
  def seconds_since_unix_epoch; end

  class << self
    def civil_from_format(utc_or_local, year, month = T.unsafe(nil), day = T.unsafe(nil), hour = T.unsafe(nil), min = T.unsafe(nil), sec = T.unsafe(nil)); end
    def current; end
  end
end

module Enumerable
  def as_json(options = T.unsafe(nil)); end
end

class Exception
  def as_json(options = T.unsafe(nil)); end
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass

  def as_json(options = T.unsafe(nil)); end
  def blank?; end
end

class Float < ::Numeric
  include ::JSON::Ext::Generator::GeneratorMethods::Float

  def as_json(options = T.unsafe(nil)); end
end

class Hash
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::Mocha::Inspect::HashMethods

  def as_json(options = T.unsafe(nil)); end
  def deep_merge(other_hash, &block); end
  def deep_merge!(other_hash, &block); end
  def except!(*keys); end
  def extract!(*keys); end
  def slice!(*keys); end
end

class IO
  include ::Enumerable
  include ::File::Constants

  def as_json(options = T.unsafe(nil)); end
end

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end

  private

  def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)

class IPAddr
  include ::Comparable

  def as_json(options = T.unsafe(nil)); end
end

class LoadError < ::ScriptError
  include ::DidYouMean::Correctable
end

class Module
  def cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end
  def cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end
  def cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end
  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end
  def delegate_missing_to(target, allow_nil: T.unsafe(nil)); end
  def mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end
  def mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end
  def mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end
  def method_visibility(method); end
  def redefine_method(method, &block); end
  def redefine_singleton_method(method, &block); end
  def silence_redefinition_of_method(method); end
end

Module::DELEGATION_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)
Module::DELEGATION_RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Set)
class Module::DelegationError < ::NoMethodError; end
Module::RUBY_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)

class NameError < ::StandardError
  include ::DidYouMean::Correctable
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass

  def as_json(options = T.unsafe(nil)); end
  def blank?; end
end

class Numeric
  include ::Comparable

  def as_json(options = T.unsafe(nil)); end
  def blank?; end
end

class Object < ::BasicObject
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Kernel
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  include ::Minitest::Expectations
  include ::Mocha::ParameterMatchers::InstanceMethods
  include ::Mocha::Inspect::ObjectMethods
  include ::Mocha::ObjectMethods

  def as_json(options = T.unsafe(nil)); end
  def blank?; end
  def instance_values; end
  def instance_variable_names; end
  def presence; end
  def present?; end
end

class Pathname
  def as_json(options = T.unsafe(nil)); end
end

class Process::Status
  def as_json(options = T.unsafe(nil)); end
end

class Range
  include ::Enumerable

  def as_json(options = T.unsafe(nil)); end
end

class Regexp
  def as_json(options = T.unsafe(nil)); end
end

Regexp::TOKEN_KEYS = T.let(T.unsafe(nil), Array)

class Regexp::Token < ::Struct
  def conditional_level; end
  def conditional_level=(_); end
  def length; end
  def level; end
  def level=(_); end
  def next; end
  def next=(_arg0); end
  def offset; end
  def previous; end
  def previous=(_arg0); end
  def set_level; end
  def set_level=(_); end
  def te; end
  def te=(_); end
  def text; end
  def text=(_); end
  def token; end
  def token=(_); end
  def ts; end
  def ts=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend

  def acts_like_string?; end
  def as_json(options = T.unsafe(nil)); end
  def at(position); end
  def blank?; end
  def camelcase(first_letter = T.unsafe(nil)); end
  def camelize(first_letter = T.unsafe(nil)); end
  def classify; end
  def constantize; end
  def dasherize; end
  def deconstantize; end
  def demodulize; end
  def first(limit = T.unsafe(nil)); end
  def foreign_key(separate_class_name_and_id_with_underscore = T.unsafe(nil)); end
  def from(position); end
  def humanize(capitalize: T.unsafe(nil), keep_id_suffix: T.unsafe(nil)); end
  def is_utf8?; end
  def last(limit = T.unsafe(nil)); end
  def mb_chars; end
  def parameterize(separator: T.unsafe(nil), preserve_case: T.unsafe(nil), locale: T.unsafe(nil)); end
  def pluralize(count = T.unsafe(nil), locale = T.unsafe(nil)); end
  def safe_constantize; end
  def singularize(locale = T.unsafe(nil)); end
  def tableize; end
  def titlecase(keep_id_suffix: T.unsafe(nil)); end
  def titleize(keep_id_suffix: T.unsafe(nil)); end
  def to(position); end
  def underscore; end
  def upcase_first; end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)

class Struct
  include ::Enumerable

  def as_json(options = T.unsafe(nil)); end
end

Struct::Group = Etc::Group
Struct::Passwd = Etc::Passwd

class Symbol
  include ::Comparable

  def as_json(options = T.unsafe(nil)); end
end

class Time
  include ::Comparable
  include ::Mocha::Inspect::TimeMethods

  def as_json(options = T.unsafe(nil)); end
  def blank?; end
  def formatted_offset(colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end
  def to_formatted_s(format = T.unsafe(nil)); end
  def to_s(format = T.unsafe(nil)); end
end

Time::DATE_FORMATS = T.let(T.unsafe(nil), Hash)

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass

  def as_json(options = T.unsafe(nil)); end
  def blank?; end
end

class URI::Generic
  include ::URI::RFC2396_REGEXP
  include ::URI

  def as_json(options = T.unsafe(nil)); end
end
